-- | A stripped down version of JSON.

module Data.JSON where

import           Control.Monad
import           Control.Monad.Reader
import           Test.QuickCheck      hiding (maxSize)

data JValue = JNull
            | JString String
            | JNumber Double
            | JBool Bool
            | JObject [(String, JValue)]
            | JArray  [JValue]
            deriving (Show)

-- * Some helper functions

-- | Gets the top level
attributes :: JValue -> [String]
attributes (JObject xs) = fst <$> xs
attributes _ = []

-- Note that the instance of Arbitrary has to be declared here:
--     http://stackoverflow.com/questions/3079537/orphaned-instances-in-haskell

-- * Our first approach:
--
-- > instance Arbitrary JValue where
-- >   arbitrary = oneof [ return JNull
-- >                     , liftM JString arbitrary
-- >                     , liftM JBool arbitrary
-- >                     , liftM JObject (listOf $ liftM2 (,) arbitrary arbitrary)
-- >                     , liftM JArray (listOf arbitrary)
-- >                     ]
--
--
-- You can see the attributes that were generated by performing:
--
-- > attributes <$> (generate  (arbitrary :: Gen JValue))
--

-- * Second approach:

class Configuration c where
  -- | The universe of valid strings.
  validString :: c -> Gen String
  -- | The maximum size of the generated objects.
  maxSize :: c -> Int
  -- | Update the maximum size.
  updateMaxSize :: (Int -> Int) -> c -> c

data Conf = Conf { _validStrings :: [String]
                 , _maxSize      :: Int
                 }

instance Configuration Conf where
  validString c = elements (_validStrings c)
  maxSize c = _maxSize c
  updateMaxSize f c = c {_maxSize = (f . _maxSize) c}

mConf :: Conf
mConf = Conf ["foo", "bar", "baz"] 4

arbitraryC :: (Configuration c) => c -> Gen JValue
arbitraryC conf =
  if (n == 0)
  then return JNull
  else oneof [ return JNull
             , liftM JString validStr
             , liftM JBool arbitrary
             , liftM JObject (vectorOf n $ liftM2 (,) validStr (arbitraryC conf'))
             , liftM JArray (vectorOf n (arbitraryC conf'))
             ]
  where validStr = validString conf
        n = maxSize conf
        conf' = updateMaxSize (\x -> x - 1) conf

type GenE c a = ReaderT c Gen a

-- * Using the reader Monad to pass the environment around.
arbitraryE :: (Configuration c) => GenE c JValue
arbitraryE =
  asks (maxSize) >>= \n -> -- Here we ask the max size to the environment ::
                           -- ReaderT c Gen Int
  asks (validString) >>= \validStr ->
    if (n == 0)
    then return (JBool True)
    else local (updateMaxSize (+(-1))) $
         mapReaderT (\gen -> oneof [ return JNull
                                   , liftM JString validStr
                                   , liftM JBool arbitrary
                                   , liftM JObject (vectorOf n $ liftM2 (,) validStr (gen))
                                   , liftM JArray (vectorOf n (gen))
                                   ]) $
         arbitraryE


-- Now we have a lot of complexity! Is it worth it?

getRandomJSON ::  IO JValue
getRandomJSON = generate $ runReaderT arbitraryE mConf

-- To print a value use:
--
-- > getRandomJSON >>= putStrLn . show
--

-- Ok, next, we want to change the behavior, so that strings are not repeated!


